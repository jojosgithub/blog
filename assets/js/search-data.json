{
  
    
        "post0": {
            "title": "Recipes for Explodatory Data Analysis by means of simple plots",
            "content": "TOC . how to simulate simple data sets | setup a template for plots | create a line plot | add a jiiter plot to the base plot | increase the dataset dimension for creating a scatter plot | . #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # loading required libraries for this notebook #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° #loading libraries library(ggplot2) library(gridExtra) library(data.table) library(RColorBrewer) library(ggrepel) library(patchwork) . Which plot to choose? . The answer depend on your data. Depending on the kind of relation you would like to highlight there are different plots that can be useful. In my workflow generally the first think I need to check is . presence of a changing in time of one (or multiple) variables | check if the data follow a distribution | check the presence of a linear correlation between the variables | For this purpose we can use . time series plots | distribution plots | correlation plots | First of all we generate some data . #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # creating a very simple dataframe #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # Parameters x_min &lt;- 0 x_max &lt;- 10 x_step &lt;- 0.01 y_mean &lt;- 0.5 y_sd &lt;- 0.25 y_min &lt;- -1 y_max &lt;- 1 x &lt;- seq(x_min,x_max,x_step) # Variables var_random &lt;- runif(x,y_min,y_max) var_norm &lt;- rnorm(x,y_mean,y_sd) var_sin &lt;- sin(x) # Data.frame df &lt;- data.frame (x,var_random,var_norm,var_sin) dt &lt;- data.table(df) # Melt dtm &lt;- melt(dt, id.vars=&quot;x&quot;) head(dtm) #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° . A data.table: 6 × 3 xvariablevalue . &lt;dbl&gt;&lt;fct&gt;&lt;dbl&gt; . 0.00 | var_random | 0.8590546 | . 0.01 | var_random | -0.7713727 | . 0.02 | var_random | 0.1710722 | . 0.03 | var_random | -0.7606114 | . 0.04 | var_random | 0.2227175 | . 0.05 | var_random | -0.9266860 | . notes about the code A few comments on the code. First of all we setup the min of x and y and also a few parameters that will e used to generate the data. as a second step we use the functions runif,rnorm and sin to create a random variable, a uniformly distributed variable and a sinusoid. We use the function data.frame to put togheter the x and vars, we then transform everything in a data.table since we need to use the function melt from the data.table library. In this case the id of each variable corrensponds to the x and so in the melt function we used as a parameter the id.vars=x . Now that we have our data we start plotting them. At first we will setup the general aspect of the plot. We will setup the general aspect of the plot and than add our points. The idea is to create a reusable &quot;template&quot; for all our exploratory data. I love both the basic R plot and ggplot. For this examples we will use ggplot and modify a theme . theme_pub &lt;- function(){ theme_minimal() %+replace% #replace elements we want to change theme( #text elements plot.title = element_text( #title size = 24, #set font size face = &#39;bold&#39;, #bold typeface hjust = 0, #left align vjust = 2), #raise slightly plot.subtitle = element_text( #subtitle size = 14), #font size plot.caption = element_text( #caption size = 9, #font size hjust = 1), #right align axis.title = element_text( #axis titles size = 10), #font size axis.text = element_text( #axis text size = 9), #font size ) } . The previous code create a personalised theme replacing the settings that can be found in the theme_minimal from ggplot. For doing that we use the command %+replace%. We just changed some text options plot, but here you can insert all the customization you want (see the ggplot reference here. Now that we have set the theme for our plot we will plot the three variables. Since we only have 3 variables we can create a line plot for each of the variable and using the library patchwork we put all of the plots together . #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # Line plot #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° options(repr.plot.width=7, repr.plot.height=7) p &lt;- ggplot(dtm[variable==&quot;var_sin&quot;], aes(x = x, y = value, group=variable)) + geom_line(aes(linetype=variable,color=variable)) + theme_pub() p1 &lt;- ggplot(dtm[variable==&quot;var_norm&quot;], aes(x = x, y = value, group=variable)) + geom_line(aes(linetype=variable,color=variable)) + theme_pub() p2 &lt;- ggplot(dtm[variable==&quot;var_random&quot;], aes(x = x, y = value, group=variable)) + geom_line(aes(linetype=variable,color=variable)) + theme_pub() p / p1 / p2 . So what does the previous lines of code works. First of all we create an object p. For ggplot every plot is just an object that we can recall later. This is very important since we can put plots in a list, we can write functions that can generate plots and in a few lines and we can take advantage of how R deals with objects also (I&#39;m using the term object with large acception here and not in a stricly language meaaning). We invock a ggplot and we tell that he should consider the data dtm as source for the plot. Since we do not want to plot all the variables we select only the variable_sin. Then we need to specify the x and y and also if we want any grouping variable. Everything included in the parenthesis after the aes() takes care of it. Now the important part: adding a line plot we use the geom_line (if you stop here and try to get a plot you will only get an empty canvas + the x and y axis and labels). This will create the line plot and finally we use the theme for the plot we just created. Finally we combine our plot using the library patchwork using the operator What does our plots tell us? We can spot without problem the sinusoid. While the other data looks noisy and random. Is there any kind of distribution in the values of our variables? Let&#39;s find it our creating histograms of the values of the variables in exam. . #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # Histogram plot #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° p3 &lt;- ggplot(dtm[variable==&quot;var_sin&quot;], aes(y = value, group=variable)) + geom_histogram(bins=20) + theme_pub() p4 &lt;- ggplot(dtm[variable==&quot;var_norm&quot;], aes(y = value, group=variable)) + geom_histogram(bins=20) + theme_pub() p5 &lt;- ggplot(dtm[variable==&quot;var_random&quot;], aes(y = value, group=variable)) + geom_histogram(bins=20) + theme_pub() p3 + p4 + p5 . notes on the code. Since dtm is a data.table we can use the following synthax dtm[variable==&quot;var_sin&quot;] to select only the variable we would like to plot. We add an histogram and with the options bins=20,R will take care of splitting the distributions in 20 bins. What do the plots tell us? It is easy to spot at a glance that we have one of the variable with a normal distribution while the other are not. The sin(x) looks as expected with higher frequencies of values at -1 and 1 and the noise variable has does not show any kind of distribution. . Now we will use another kind of plot to see how the data are distributed. What is called a jiiter plot . pj1 &lt;- ggplot(dtm, aes(x=variable,y = value, group=variable)) + geom_jitter(position = position_jitter(0.1),alpha=0.1,, size = 3) + theme_pub() pj1 . notes on the code: in this case we just used all the dataframe with the variable as x and the y as the value. since we have lots of points we used an alpha value of 0.1 in order to have a nice effect on the plot. About the results. the concentration of points (absent in the first case, concentrated on a mean value, at the border for the sinusoidal values) gives us a perfect glance of the distribution of the values. Finally in order to explore Let&#39;s add a second se of &quot;measurements&quot; for each variable to the dataset previously created and let&#39;s plot them . # new variables #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° var_random2 &lt;- runif(x,y_min,y_max) var_norm2 &lt;- rnorm(x,y_mean,y_sd) var_sin2 &lt;- sin(x) + rnorm(x,0,0.01) . At first we will plot them and add them to the previous plot . p7 &lt;- p + geom_line(aes(y=var_sin2, color=&quot;blue&quot;)) p8 &lt;- p1 + geom_line(aes(y=var_norm2, color=&quot;blue&quot;)) p9 &lt;- p2 + geom_line(aes(y=var_random2, color=&quot;blue&quot;)) p7 / p8 / p9 . we could have changed the dataframe and add the new columns but the versatility of ggplot let us add a new layer of plot and also specify the new color we would like to use for it. Are these &quot;second measurements&quot;s correlated in comparison with the previous one? We can check it using a scatter plot. ggplot can help us with the command geom points but this time for sake of clarity we will first merge the new data with the dataframe . options(repr.plot.width=14, repr.plot.height=7) df2&lt;- data.frame(df,var_sin2,var_norm2,var_random2) dt2 &lt;- data.table(df2) p10 &lt;- ggplot(dt2) + geom_point(aes(x=var_sin,y=var_sin2)) + theme_pub() p11 &lt;- ggplot(dt2) + geom_point(aes(x=var_norm,y=var_norm2)) + theme_pub() p12 &lt;- ggplot(dt2) + geom_point(aes(x=var_random,y=var_random2))+ theme_pub() p10 + p11 + p12 . A few notes. We did not use melt since we just needed to select the cols from our newly created dataframe. (If needed a melt data.table can be reshape using the command dcast) We plotted them in pairs because we wanted to see if the &quot;first measurement&quot; was in some way correlated to the &quot;second one&quot; In the first plot we&#39;ve seen the pair of sinusoidal variables. We creaed them as correlated and in fact if we plot one vs the other we can see that the points lie on the bisect of the I and IV quadrant. They are positively lineary correlated. Then we have the norm variables. both of them are created at taking random numbers from a normal distribution. Finally the random vars. totally random and no correlation between them as expected. The aspect of the plot was changed in order to give more space to the plot .",
            "url": "https://jojosgithub.github.io/blog/r/ggplot/recipes/2021/06/18/eda.html",
            "relUrl": "/r/ggplot/recipes/2021/06/18/eda.html",
            "date": " • Jun 18, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Simulated Dataset",
            "content": "TOC . writing a function for creating a dataset with a desired number of rows and cols given a mean and an sd (same for all cols) | writing a function for creating a small dataset (n col &lt; 5) with a desired number of rows and cols given a mean and an sd (different for each cols) | writing a function for creating a dataset (n col &gt; 5) with a desired number of rows and cols given a mean and an sd (different for each cols) | writing functions for creating automatic labels for ID and categories | . #°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # loading required libraries for this notebook #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° #loading libraries library(ggplot2) library(gridExtra) library(data.table) #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # Example 1 a very simple test dataset #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # we are creating a dataframe from a matrix obtained replicating x # the desired number_of_cols a vector of length number_of_rows from # a normal distribution rnorm with a mean of my mean and standard deviation as sd number_of_rows &lt;- 7 number_of_cols &lt;- 6 my_mean &lt;- 2 my_sd &lt;- 0.5 newdat &lt;- as.data.frame( replicate( number_of_cols, rnorm(n = number_of_rows, mean = my_mean, sd = my_sd )) ) #in order to print a fancy table newdat . A data.frame: 7 × 6 V1V2V3V4V5V6 . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 2.166144 | 2.234508 | 1.626651 | 1.628226 | 1.8127086 | 1.527190 | . 1.775968 | 2.038753 | 1.992165 | 2.595088 | 1.2067000 | 2.231039 | . 3.054668 | 2.092037 | 2.260662 | 1.963266 | 1.8069252 | 1.650384 | . 1.590842 | 1.575725 | 2.410852 | 1.303806 | 0.9177386 | 2.084656 | . 1.796939 | 1.845413 | 1.838408 | 1.938406 | 2.1200911 | 2.051055 | . 2.151737 | 2.221940 | 2.099623 | 1.985790 | 1.7742916 | 2.657077 | . 1.896525 | 1.808077 | 1.279979 | 2.216669 | 1.7692324 | 2.933211 | . note about code: we create a data.frame using replicate to replicate a serie of vectors with normal distributions generated with rnorm . Code for creating small (n col &lt; 5) dataset. Each column has its own mean and sd. In the example reported we have n = 3 (A, B, C) with n row = 50. means are 100,110,120 and sd 1,2,3 | . #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # Ex 2 Another way for a simple dataset #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° #in order to obtain ALWAYS same &quot;random&quot; results REMEMBER TO initialize the seed #set.seed(42) number_of_rows &lt;- 5 A &lt;- rnorm( n=number_of_rows, mean=100, sd=1 ) B &lt;- rnorm( n=number_of_rows, mean=110, sd=2 ) C &lt;- rnorm( n=number_of_rows, mean=120, sd=2 ) dat=data.frame(A,B,C) dat . A data.frame: 5 × 3 ABC . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 99.46789 | 105.4446 | 120.8604 | . 99.59229 | 109.9107 | 120.2226 | . 98.89571 | 113.7015 | 121.1714 | . 99.85707 | 108.1090 | 117.6852 | . 101.72180 | 107.9054 | 115.4649 | . same as the one above but more useful for dataset with i columns n col &gt; 5 | . #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # Ex 3 recipes for adding labels #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° number_of_rows = 3 means=c(100, 120, 130, 145) sds=c(10 ,20 ,40 ,10) dat &lt;- lapply( seq(1,length(means)) , function(x) rnorm(number_of_rows,m = means[x], sds[x]) ) dat &lt;- as.data.frame(do.call(cbind, dat)) names_length = 3 dictionary_size &lt;- 10 my_labels &lt;- sort( replicate( length(means), paste(sample(LETTERS[1:dictionary_size], names_length, replace = TRUE), collapse=&quot;&quot;) ) ) my_labels &lt;- unlist(strsplit(my_labels,&quot; &quot;)) colnames(dat) &lt;- my_labels dat . A data.frame: 3 × 4 AEEEJGGCBHJB . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 112.84129 | 134.70014 | 85.59177 | 152.8205 | . 90.87335 | 112.58295 | 120.14683 | 163.0333 | . 110.84161 | 96.70662 | 108.93522 | 145.0431 | . Same as above but shorter | . #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # Ex 4 a variation on recipe 2 #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # building a function for generating data with custom number of rows, means and sds simpleDataset &lt;- function(number_of_rows,means,sds) { l &lt;- length(means) res &lt;- lapply(seq(1:l),function(x) eval( parse(text=paste(&quot;rnorm(&quot;,number_of_rows,&quot;,&quot;,means[x],&quot;,&quot;,sds[x],&quot;)&quot;,sep=&quot;&quot;))) ) dat &lt;- data.frame((sapply(res,c))) id &lt;- rownames(dat) dat &lt;- cbind(id=id,dat) dt &lt;- data.table(dat) return(dt) } dat1 &lt;- simpleDataset(number_of_rows=30, means=c(180,200,205), sds=c(30,20,25)) dat2 &lt;- simpleDataset(number_of_rows=30, means=c(45,50,35), sds=c(2,10,5)) dat &lt;- rbind(dat1,dat2) # rearranging table using melt from data.table dt.melt &lt;- melt(dat, id.vars=&quot;id&quot;) colnames(dt.melt) &lt;- c(&quot;id&quot;,&quot;category&quot;,&quot;var1&quot;) . to create sample names or labels (see https://stackoverflow.com/a/60789938/6483091) | . note on the code: the core line is parse(text=paste(&quot;rnorm(&quot;,number_of_rows,&quot;,&quot;,means[x],&quot;,&quot;,sds[x],&quot;)&quot;,sep=&quot;&quot;))) where we use parse inside the lapply . #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° # More recipes for labelling #+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++° #short names my_labels &lt;- letters[1:5] my_labels # or &lt;- my_labels &lt;- LETTERS[1:5] my_labels # or arbitrary number of letters using roman letters as in the #function # letters() or LETTERS() dictionary_size &lt;- 7 label_length &lt;- 5 n_replicates &lt;- 3 #random my_labels &lt;- replicate( n_replicates, paste(sample(LETTERS[1:dictionary_size], label_length, replace = TRUE), collapse=&quot;&quot;) ) my_labels #sorted my_labels_sorted &lt;- sort(replicate( n_replicates, paste (sample(LETTERS[1:dictionary_size], label_length, replace = TRUE), collapse=&quot;&quot;) ) ) my_labels_sorted #if you want to mix letters and numbers alfanum_labels &lt;- paste0(rep(LETTERS[1:dictionary_size], each = n_replicates), sep = &quot;-&quot;, 1:n_replicates) alfanum_labels . &lt;ol class=list-inline&gt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39; | &#39;d&#39; | &#39;e&#39; | &lt;/ol&gt; &lt;ol class=list-inline&gt;&#39;A&#39; | &#39;B&#39; | &#39;C&#39; | &#39;D&#39; | &#39;E&#39; | &lt;/ol&gt; &lt;ol class=list-inline&gt;&#39;GBEAF&#39; | &#39;DCEAC&#39; | &#39;FBGDG&#39; | &lt;/ol&gt; &lt;ol class=list-inline&gt;&#39;BGGEB&#39; | &#39;EDBBE&#39; | &#39;GGEBF&#39; | &lt;/ol&gt; &lt;ol class=list-inline&gt;&#39;A-1&#39; | &#39;A-2&#39; | &#39;A-3&#39; | &#39;B-1&#39; | &#39;B-2&#39; | &#39;B-3&#39; | &#39;C-1&#39; | &#39;C-2&#39; | &#39;C-3&#39; | &#39;D-1&#39; | &#39;D-2&#39; | &#39;D-3&#39; | &#39;E-1&#39; | &#39;E-2&#39; | &#39;E-3&#39; | &#39;F-1&#39; | &#39;F-2&#39; | &#39;F-3&#39; | &#39;G-1&#39; | &#39;G-2&#39; | &#39;G-3&#39; | &lt;/ol&gt;",
            "url": "https://jojosgithub.github.io/blog/r/2021/06/18/dataset.html",
            "relUrl": "/r/2021/06/18/dataset.html",
            "date": " • Jun 18, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I’m a researcher at the National Research Council of Italy at the “Giulio Natta” Institute of Chemical Sciences and Technologies (Scitec-Cnr).I started to be interested in multivariate statistics techniques applied to data from physic-chemical analysis methods 15 years ago during my Ph.D. and to apply it to material science ever since. Enthusiast about programming in R and Python in order to write tools for everyday laboratory activities. FOSS advocate. Messy coder. I’ve written also a book on this topic: “Statistical and Multivariate Analysis in Material Science” that you can find here https://amzn.com/B08W8W5WSF .",
          "url": "https://jojosgithub.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jojosgithub.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}