{
  
    
        "post0": {
            "title": "Yule-Simpson's paradox data generator",
            "content": "TOC . write a function for generating Yule-Simpson&#39;s paradox dataset(s) | . For a detailed description of Simpson paradox (and also to see it in a different than usual contest) I suggest to read &quot;Spanos, A. Yule–Simpson’s paradox: the probabilistic versus the empirical conundrum . Stat Methods Appl 30, 605–635 (2021). https://doi.org/10.1007/s10260-020-00536-4&quot; Since this is a just a blog I prefer to show you some plots. First of all we load datasaurus library and then we load the simpson dataset and we plot it with the help of ggplot . obligatory references: . Simpson, E.H. (1951), The Interpretation of Interaction in Contingency Tables. Journal of the Royal Statistical Society: Series B (Methodological), 13: 238-241. https://doi.org/10.1111/j.2517-6161.1951.tb00088.x . G. UNDY YULE, NOTES ON THE THEORY OF ASSOCIATION OF ATTRIBUTES IN STATISTICS, Biometrika, Volume 2, Issue 2, February 1903, Pages 121–134, https://doi.org/10.1093/biomet/2.2.121 . Matejka, J., &amp; Fitzmaurice, G. (2017). Same Stats, Different Graphs: Generating Datasets with Varied Appearance and Identical Statistics through Simulated Annealing. CHI 2017 Conference proceedings: ACM SIGCHI Conference on Human Factors in Computing Systems. Retrieved from https://www.autodeskresearch.com/publications/samestats. . library(data.table) library(ggplot2) library(datasauRus) options(repr.plot.width=18.8, repr.plot.height=8.9,units=&quot;cm&quot;) if(require(ggplot2)){ p &lt;- ggplot(simpsons_paradox, aes(x=x, y=y, colour=dataset))+ geom_point(size=4,alpha=0.55)+ theme(legend.position = &quot;none&quot;)+ facet_wrap(~dataset, ncol=3) } p + theme_light(base_size = 20) . what you are seing is (from the description) &quot;A dataset demonstrating Simpson&#39;s Paradox with a strongly positively correlated dataset (simpson_1) and a dataset with the same positive correlation as simpson_1, but where individual groups have a strong negative correlation (simpson_2)&quot;. So is it possible to write a function to create random Yule-Simpson&#39;s paradox dataset? Let&#39;s try it (but first of all we add a regression line as shown in https://stackoverflow.com/a/15654715/6483091 and https://stackoverflow.com/a/37504482/6483091 . library(ggpmisc) method &lt;- y ~ x pp &lt;- ggplot(simpsons_paradox, aes(x= x, y= y, color = dataset)) + geom_point(size=4,alpha=0.55) + facet_wrap(~dataset, ncol=3) + geom_smooth(method = &quot;lm&quot;, formula = method, se = F) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = -1, formula = method, parse = TRUE, size = 6) pp + theme_light(base_size = 20) . the strategy that we will follow is simple. and it is again very &quot;brutal&quot; and not formal at all. the idea is . create a starting and ending x for the x y dataset we are creating | (add noise) | divide in n intervals/step the xend-xstart | create distributions (normal, uniform, gaussian,whatever) for each step | rotate all the distributions (simple trigonometry) the code is the following, but again plots will better explain the strategy Before implementing the step we try to see how to create a distribution and rotate it | library(data.table) library(foreach) library(ggpmisc) points_dist=50 theta=seq(-1,1,0.1) options(repr.plot.width=8.9, repr.plot.height=8.9,units=&quot;cm&quot;) x &lt;- rnorm(points_dist,0,1) y &lt;- rnorm(points_dist,0,0.2) xi &lt;- x*cos(pi*theta)-y*sin(pi*theta) yi &lt;- x*sin(pi*theta)-y*cos(pi*theta) m=3 xstart=1 xend=10 xseq &lt;- seq(xstart,xend,2) yseq &lt;- m*xseq library(foreach) xsimp &lt;- foreach(i=1:length(xseq)) %do% { xseq[i]+xi } ysimp &lt;- foreach(i=1:length(yseq)) %do% { yseq[i]+yi } xysimp &lt;- data.table(unlist(xsimp),unlist(ysimp)) colnames(xysimp) &lt;- c(&quot;x&quot;,&quot;y&quot;) method &lt;- y ~ x p2 &lt;- ggplot(xysimp, aes(x= x, y= y)) + geom_point(size=4,alpha=0.55,colour = &quot;red&quot;) + geom_smooth(method = &quot;lm&quot;, formula = method, color = &quot;red&quot;, size=1, se = F) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = -1, formula = method, parse = TRUE, size = 6) p2 + theme_light(base_size = 20) . Warning message in x * cos(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; Warning message in y * sin(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; Warning message in x * sin(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; Warning message in y * cos(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; . ok it seems to work. Let&#39;s wrap it in a function (we also add a set.seed in order to randomize each group) . library(data.table) library(foreach) #we now write everything in form of a function yulsim &lt;- function(m=3,xstart=1,xend=10,theta=-0.3,step=0.5,nfx=0.1,nfy=0.5,npoints=100,coeff=2){ m=m xstart=xstart xend=xend xseq &lt;- seq(xstart,xend,step) yseq &lt;- coeff + m*xseq xsimp &lt;- foreach(i=1:length(xseq)) %do% { set.seed(i*4) x &lt;- rnorm(npoints,0,nfx) xi &lt;- x*cos(pi*theta)-y*sin(pi*theta) xseq[i]+xi } ysimp &lt;- foreach(i=1:length(yseq)) %do% { set.seed(i*3) y &lt;- rnorm(npoints,0,nfy) yi &lt;- x*sin(pi*theta)-y*cos(pi*theta) yseq[i]+yi } ldat &lt;- data.table(xsimp,ysimp) dat &lt;- data.table(unlist(xsimp),unlist(ysimp)) colnames(dat) &lt;- c(&quot;x&quot;,&quot;y&quot;) my.list &lt;- list(&quot;lout&quot;=ldat,&quot;out&quot;=dat) return(my.list) } . a few more test with ggplot . options(repr.plot.width=18.8, repr.plot.height=8.9,units=&quot;cm&quot;) st1 &lt;- yulsim (m=-3,xstart=20,xend=80,theta=0.4,step=20,nfx=12,nfy=2,npoints=100,coeff=-5) st2 &lt;- yulsim (m=-2,xstart=20,xend=80,theta=0.4,step=20,nfx=12,nfy=2,npoints=100,coeff=-5) ys1 &lt;- st1$out ys2 &lt;- st2$out ys1$set &lt;- &quot;ys_1&quot; ys2$set &lt;- &quot;ys_2&quot; ysset &lt;- rbind(ys1,ys2) p2 &lt;- ggplot(ysset, aes(x=x, y=y, colour=set))+ geom_point(size=4,alpha=0.55)+ theme(legend.position = &quot;none&quot;)+ facet_wrap(~set, ncol=2) + geom_smooth(method = &quot;lm&quot;, formula = method, se = F) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = -1, formula = method, parse = TRUE, size = 6) p2 + theme_light(base_size = 20) . and everything seems to work fine. The function is quite brutal, we can indeed change also the distributions used, but it is very flexible and does its job. so now we can generate as much as we want y-s dataset .",
            "url": "https://jojosgithub.github.io/blog/r/ggplot/recipes/simpson/2021/07/04/ys.html",
            "relUrl": "/r/ggplot/recipes/simpson/2021/07/04/ys.html",
            "date": " • Jul 4, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Yule-Simpson's paradox data generator",
            "content": "TOC . have fun using the package gtrends (https://cran.r-project.org/web/packages/gtrendsR/) | . library(data.table) library(ggplot2) library(datasauRus) options(repr.plot.width=12, repr.plot.height=8) if(require(ggplot2)){ p &lt;- ggplot(simpsons_paradox, aes(x=x, y=y, colour=dataset))+ geom_point(size=4,alpha=0.55)+ theme(legend.position = &quot;none&quot;)+ facet_wrap(~dataset, ncol=3) } p + theme_light(base_size = 20) . what you are seing is (from the description) &quot;A dataset demonstrating Simpson&#39;s Paradox with a strongly positively correlated dataset (simpson_1) and a dataset with the same positive correlation as simpson_1, but where individual groups have a strong negative correlation (simpson_2)&quot;. So is it possible to write a function to create random Yule-Simpson&#39;s paradox dataset? Let&#39;s try it (but first of all we add a regression line as shown in https://stackoverflow.com/a/15654715/6483091 and https://stackoverflow.com/a/37504482/6483091 . library(ggpmisc) method &lt;- y ~ x pp &lt;- ggplot(simpsons_paradox, aes(x= x, y= y, color = dataset)) + geom_point(size=4,alpha=0.55) + facet_wrap(~dataset, ncol=3) + geom_smooth(method = &quot;lm&quot;, formula = method, se = F) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = -1, formula = method, parse = TRUE, size = 6) pp + theme_light(base_size = 20) . the strategy that we will follow is simple. and it is again very &quot;brutal&quot; and not formal at all. the idea is . create a starting and ending x for the x y dataset we are creating | (add noise) | divide in n intervals/step the xend-xstart | create distributions (normal, uniform, gaussian,whatever) for each step | rotate all the distributions (simple trigonometry) the code is the following, but again plots will better explain the strategy Before implementing the step we try to see how to create a distribution and rotate it | library(data.table) library(foreach) library(ggpmisc) points_dist=100 theta=seq(-1,1,0.1) x &lt;- rnorm(points_dist,0,0.5) y &lt;- rnorm(points_dist,0,0.2) xi &lt;- x*cos(pi*theta)-y*sin(pi*theta) yi &lt;- x*sin(pi*theta)-y*cos(pi*theta) m=3 xstart=1 xend=10 xseq &lt;- seq(xstart,xend,2) yseq &lt;- m*xseq library(foreach) xsimp &lt;- foreach(i=1:length(xseq)) %do% { xseq[i]+xi } ysimp &lt;- foreach(i=1:length(yseq)) %do% { yseq[i]+yi } xysimp &lt;- data.table(unlist(xsimp),unlist(ysimp)) colnames(xysimp) &lt;- c(&quot;x&quot;,&quot;y&quot;) method &lt;- y ~ x p2 &lt;- ggplot(xysimp, aes(x= x, y= y)) + geom_point(size=4,alpha=0.15) + geom_smooth(method = &quot;lm&quot;, formula = method, se = F) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = -1, formula = method, parse = TRUE, size = 6) p2 + theme_classic(base_size = 20) . Warning message in x * cos(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; Warning message in y * sin(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; Warning message in x * sin(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; Warning message in y * cos(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; . note: I used the base plot since it is was faster for me for prototyping amd inserting it in a loop the trick for creating the colors is taken from https://rjbioinformatics.com/2016/07/10/creating-color-palettes-in-r/ and http://www.colbyimaging.com/wiki/statistics/color-bars. now we are ready to test this snippets to create a simpson plot . ok it seems to work. Let&#39;s wrap it in a function . library(data.table) #we now write everything in form of a function yulsim &lt;- function(m=3,xstart=1,xend=10,theta=-0.3,step=0.5,nfx=0.1,nfy=0.5,npoints=100,coeff=2){ x &lt;- rnorm(npoints,0,nfx) y &lt;- rnorm(npoints,0,nfy) xi &lt;- x*cos(pi*theta)-y*sin(pi*theta) yi &lt;- x*sin(pi*theta)-y*cos(pi*theta) m=m xstart=xstart xend=xend xseq &lt;- seq(xstart,xend,step) yseq &lt;- coeff + m*xseq library(foreach) xsimp &lt;- foreach(i=1:length(xseq)) %do% { xseq[i]+xi } ysimp &lt;- foreach(i=1:length(yseq)) %do% { yseq[i]+yi } ldat &lt;- data.table(xsimp,ysimp) dat &lt;- data.table(unlist(xsimp),unlist(ysimp)) colnames(dat) &lt;- c(&quot;x&quot;,&quot;y&quot;) my.list &lt;- list(&quot;lout&quot;=ldat,&quot;out&quot;=dat) return(my.list) } . a few more test with ggplot . st1 &lt;- yulsim (m=-3,xstart=20,xend=80,theta=0.4,step=20,nfx=12,nfy=2,npoints=100,coeff=-5) st2 &lt;- yulsim (m=-2,xstart=20,xend=80,theta=0.4,step=20,nfx=12,nfy=2,npoints=100,coeff=-5) ys1 &lt;- st1$out ys2 &lt;- st2$out ys1$set &lt;- &quot;ys_1&quot; ys2$set &lt;- &quot;ys_2&quot; ysset &lt;- rbind(ys1,ys2) p2 &lt;- ggplot(ysset, aes(x=x, y=y, colour=set))+ geom_point(size=4,alpha=0.55)+ theme(legend.position = &quot;none&quot;)+ facet_wrap(~set, ncol=2) + geom_smooth(method = &quot;lm&quot;, formula = formula, se = F) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = -1, formula = formula, parse = TRUE, size = 6) p2 + theme_classic(base_size = 22) . and everything seems to work fine. The function is quite brutal, we can indeed change also the distributions used, but it is very flexible and does its job. so now we can generate as much as we want y-s dataset .",
            "url": "https://jojosgithub.github.io/blog/r/google/trends/2021/07/04/trends.html",
            "relUrl": "/r/google/trends/2021/07/04/trends.html",
            "date": " • Jul 4, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Anscombe's  quartet",
            "content": "TOC . can we create a function to recreate infinite Anscombe&#39;s quartet even with more points? | . For a detailed description of Anscombe quartet see, F. J. &quot;Graphs in Statistical Analysis.&quot; The American Statistician 27, no. 1 (1973): 17-21. Accessed July 4, 2021. doi:10.2307/2682899. Let&#39;s start importing the data and plot them also we will add the regression labs . library(ggpmisc) library(data.table) library(ggplot2) library(datasauRus) options(repr.plot.width=8.9, repr.plot.height=8.9,units=&quot;cm&quot;) anscombe #rearrange to create a ggplot + regression set1 &lt;- data.frame(anscombe$x1, anscombe$y1) set1$set &lt;- &quot;set1&quot; colnames(set1) &lt;- c(&quot;x&quot;,&quot;y&quot;,&quot;set&quot;) set2 &lt;- data.frame(anscombe$x2, anscombe$y2) set2$set &lt;- &quot;set2&quot; colnames(set2) &lt;- c(&quot;x&quot;,&quot;y&quot;,&quot;set&quot;) set3 &lt;- data.frame(anscombe$x3, anscombe$y3) set3$set &lt;- &quot;set3&quot; colnames(set3) &lt;- c(&quot;x&quot;,&quot;y&quot;,&quot;set&quot;) set4 &lt;- data.frame(anscombe$x4, anscombe$y4) set4$set &lt;- &quot;set4&quot; colnames(set4) &lt;- c(&quot;x&quot;,&quot;y&quot;,&quot;set&quot;) gganscombe &lt;- rbind(set1,set2,set3,set4) colnames(gganscombe) &lt;- c(&quot;x&quot;,&quot;y&quot;,&quot;set&quot;) #we need to define the formula before using them in ggsmooth see #https://stackoverflow.com/a/39333833/6483091 formula &lt;- y ~ x p &lt;- ggplot(gganscombe, aes(x= x, y= y, color = set)) + geom_point(alpha = 0.3,size = 4) + facet_wrap(~set, ncol=2) + geom_smooth(method = &quot;lm&quot;, formula = formula, se = T) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = 0.15, formula = formula, parse = TRUE, size = 6) p+theme_light(base_size=20) x=gganscombe$x y=gganscombe$y . A data.frame: 11 × 8 x1x2x3x4y1y2y3y4 . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 10 | 10 | 10 | 8 | 8.04 | 9.14 | 7.46 | 6.58 | . 8 | 8 | 8 | 8 | 6.95 | 8.14 | 6.77 | 5.76 | . 13 | 13 | 13 | 8 | 7.58 | 8.74 | 12.74 | 7.71 | . 9 | 9 | 9 | 8 | 8.81 | 8.77 | 7.11 | 8.84 | . 11 | 11 | 11 | 8 | 8.33 | 9.26 | 7.81 | 8.47 | . 14 | 14 | 14 | 8 | 9.96 | 8.10 | 8.84 | 7.04 | . 6 | 6 | 6 | 8 | 7.24 | 6.13 | 6.08 | 5.25 | . 4 | 4 | 4 | 19 | 4.26 | 3.10 | 5.39 | 12.50 | . 12 | 12 | 12 | 8 | 10.84 | 9.13 | 8.15 | 5.56 | . 7 | 7 | 7 | 8 | 4.82 | 7.26 | 6.42 | 7.91 | . 5 | 5 | 5 | 8 | 5.68 | 4.74 | 5.73 | 6.89 | . #which trick was used??? #let&#39;s try to rotate a bit the points.. #theta=-1/2 library(foreach) theta &lt;- seq(0,0.13,0.01) a &lt;- foreach(i=1:length(theta)) %do% { gganscombe$xi &lt;- (x*cos(pi*theta[i])-y*sin(pi*theta[i])) gganscombe$yi &lt;- (x*sin(pi*theta[i])-y*cos(pi*theta[i])) #(look also at the error ! essentially perfect fit: summary may be unreliable) p &lt;- ggplot(gganscombe, aes(x= xi, y= yi, color = set)) + geom_point(aes(size = 6),alpha = 0.3) + facet_wrap(~set, ncol=2) + geom_smooth(method = &quot;lm&quot;, formula = formula, se = T) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = 0.15, formula = formula, parse = TRUE, size = 6) + theme_light(base_size=20) } a[[1]] a[[6]] a[[14]] . #an example of manually creating a simmetric dataset (look at the R with more points as expected and also compare the stats.. #the secret is all in the simmetry) xn1 &lt;- c(4.28,4.65,5.17, 5.79, 6.17, 6.65, 7.17, 7.70, 8.28, 9.06, 10.11,11.11, 11.90,12.73,13.29, 13.66) yn1 &lt;- c(5.10, 5.29, 5.58, 5.88, 5.35, 6.61, 7.06, 7.44, 7.77, 7.90, 7.94, 7.97, 9.09, 9.51, 9.81, 10.04) datn1 &lt;- data.frame(xn1,yn1) pnew &lt;- ggplot(datn1, aes(x = xn1, y= yn1)) + geom_point(aes(size = 8),alpha = 0.3) + geom_smooth(method = &quot;lm&quot;, formula = formula, se = T) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = 0.15, formula = formula, parse = TRUE, size = 8) pnew + theme_light(base_size=20) summary(datn1) . xn1 yn1 Min. : 4.280 Min. : 5.100 1st Qu.: 6.075 1st Qu.: 5.805 Median : 7.990 Median : 7.605 Mean : 8.607 Mean : 7.396 3rd Qu.:11.307 3rd Qu.: 8.250 Max. :13.660 Max. :10.040 .",
            "url": "https://jojosgithub.github.io/blog/r/ggplot/recipes/simpson/2021/07/04/anscombe.html",
            "relUrl": "/r/ggplot/recipes/simpson/2021/07/04/anscombe.html",
            "date": " • Jul 4, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I’m a researcher at the National Research Council of Italy at the “Giulio Natta” Institute of Chemical Sciences and Technologies (Scitec-Cnr).I started to be interested in multivariate statistics techniques applied to data from physic-chemical analysis methods 15 years ago during my Ph.D. and to apply it to material science ever since. Enthusiast about programming in R and Python in order to write tools for everyday laboratory activities. FOSS advocate. Messy coder. I’ve written also a book on this topic: “Statistical and Multivariate Analysis in Material Science” that you can find here https://amzn.com/B08W8W5WSF .",
          "url": "https://jojosgithub.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jojosgithub.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}