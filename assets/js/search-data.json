{
  
    
        "post0": {
            "title": "Yule-Simpson's paradox data generator",
            "content": "TOC . write a function for generating Yule-Simpson&#39;s paradox dataset(s) | . For a detailed description of Simpson paradox (and also to see it in a different than usual contest) I suggest to read &quot;Spanos, A. Yule–Simpson’s paradox: the probabilistic versus the empirical conundrum . Stat Methods Appl 30, 605–635 (2021). https://doi.org/10.1007/s10260-020-00536-4&quot; Since this is a just a blog I prefer to show you some plots. First of all we load datasaurus library and then we load the simpson dataset and we plot it with the help of ggplot . obligatory references: . Simpson, E.H. (1951), The Interpretation of Interaction in Contingency Tables. Journal of the Royal Statistical Society: Series B (Methodological), 13: 238-241. https://doi.org/10.1111/j.2517-6161.1951.tb00088.x . G. UNDY YULE, NOTES ON THE THEORY OF ASSOCIATION OF ATTRIBUTES IN STATISTICS, Biometrika, Volume 2, Issue 2, February 1903, Pages 121–134, https://doi.org/10.1093/biomet/2.2.121 . Matejka, J., &amp; Fitzmaurice, G. (2017). Same Stats, Different Graphs: Generating Datasets with Varied Appearance and Identical Statistics through Simulated Annealing. CHI 2017 Conference proceedings: ACM SIGCHI Conference on Human Factors in Computing Systems. Retrieved from https://www.autodeskresearch.com/publications/samestats. . library(data.table) library(ggplot2) library(datasauRus) options(repr.plot.width=18.8, repr.plot.height=8.9,units=&quot;cm&quot;) if(require(ggplot2)){ p &lt;- ggplot(simpsons_paradox, aes(x=x, y=y, colour=dataset))+ geom_point(size=4,alpha=0.55)+ theme(legend.position = &quot;none&quot;)+ facet_wrap(~dataset, ncol=3) } p + theme_light(base_size = 20) . what you are seing is (from the description) &quot;A dataset demonstrating Simpson&#39;s Paradox with a strongly positively correlated dataset (simpson_1) and a dataset with the same positive correlation as simpson_1, but where individual groups have a strong negative correlation (simpson_2)&quot;. So is it possible to write a function to create random Yule-Simpson&#39;s paradox dataset? Let&#39;s try it (but first of all we add a regression line as shown in https://stackoverflow.com/a/15654715/6483091 and https://stackoverflow.com/a/37504482/6483091 . library(ggpmisc) method &lt;- y ~ x pp &lt;- ggplot(simpsons_paradox, aes(x= x, y= y, color = dataset)) + geom_point(size=4,alpha=0.55) + facet_wrap(~dataset, ncol=3) + geom_smooth(method = &quot;lm&quot;, formula = method, se = F) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = -1, formula = method, parse = TRUE, size = 6) pp + theme_light(base_size = 20) . the strategy that we will follow is simple. and it is again very &quot;brutal&quot; and not formal at all. the idea is . create a starting and ending x for the x y dataset we are creating | (add noise) | divide in n intervals/step the xend-xstart | create distributions (normal, uniform, gaussian,whatever) for each step | rotate all the distributions (simple trigonometry) the code is the following, but again plots will better explain the strategy Before implementing the step we try to see how to create a distribution and rotate it | library(data.table) library(foreach) library(ggpmisc) points_dist=50 theta=seq(-1,1,0.1) options(repr.plot.width=8.9, repr.plot.height=8.9,units=&quot;cm&quot;) x &lt;- rnorm(points_dist,0,1) y &lt;- rnorm(points_dist,0,0.2) xi &lt;- x*cos(pi*theta)-y*sin(pi*theta) yi &lt;- x*sin(pi*theta)-y*cos(pi*theta) m=3 xstart=1 xend=10 xseq &lt;- seq(xstart,xend,2) yseq &lt;- m*xseq library(foreach) xsimp &lt;- foreach(i=1:length(xseq)) %do% { xseq[i]+xi } ysimp &lt;- foreach(i=1:length(yseq)) %do% { yseq[i]+yi } xysimp &lt;- data.table(unlist(xsimp),unlist(ysimp)) colnames(xysimp) &lt;- c(&quot;x&quot;,&quot;y&quot;) method &lt;- y ~ x p2 &lt;- ggplot(xysimp, aes(x= x, y= y)) + geom_point(size=4,alpha=0.55,colour = &quot;red&quot;) + geom_smooth(method = &quot;lm&quot;, formula = method, color = &quot;red&quot;, size=1, se = F) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = -1, formula = method, parse = TRUE, size = 6) p2 + theme_light(base_size = 20) . Warning message in x * cos(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; Warning message in y * sin(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; Warning message in x * sin(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; Warning message in y * cos(pi * theta): &#34;longer object length is not a multiple of shorter object length&#34; . ok it seems to work. Let&#39;s wrap it in a function (we also add a set.seed in order to randomize each group) . library(data.table) library(foreach) #we now write everything in form of a function yulsim &lt;- function(m=3,xstart=1,xend=10,theta=-0.3,step=0.5,nfx=0.1,nfy=0.5,npoints=100,coeff=2){ m=m xstart=xstart xend=xend xseq &lt;- seq(xstart,xend,step) yseq &lt;- coeff + m*xseq xsimp &lt;- foreach(i=1:length(xseq)) %do% { set.seed(i*4) x &lt;- rnorm(npoints,0,nfx) xi &lt;- x*cos(pi*theta)-y*sin(pi*theta) xseq[i]+xi } ysimp &lt;- foreach(i=1:length(yseq)) %do% { set.seed(i*3) y &lt;- rnorm(npoints,0,nfy) yi &lt;- x*sin(pi*theta)-y*cos(pi*theta) yseq[i]+yi } ldat &lt;- data.table(xsimp,ysimp) dat &lt;- data.table(unlist(xsimp),unlist(ysimp)) colnames(dat) &lt;- c(&quot;x&quot;,&quot;y&quot;) my.list &lt;- list(&quot;lout&quot;=ldat,&quot;out&quot;=dat) return(my.list) } . a few more test with ggplot . options(repr.plot.width=18.8, repr.plot.height=8.9,units=&quot;cm&quot;) st1 &lt;- yulsim (m=-3,xstart=20,xend=80,theta=0.4,step=20,nfx=12,nfy=2,npoints=100,coeff=-5) st2 &lt;- yulsim (m=-2,xstart=20,xend=80,theta=0.4,step=20,nfx=12,nfy=2,npoints=100,coeff=-5) ys1 &lt;- st1$out ys2 &lt;- st2$out ys1$set &lt;- &quot;ys_1&quot; ys2$set &lt;- &quot;ys_2&quot; ysset &lt;- rbind(ys1,ys2) p2 &lt;- ggplot(ysset, aes(x=x, y=y, colour=set))+ geom_point(size=4,alpha=0.55)+ theme(legend.position = &quot;none&quot;)+ facet_wrap(~set, ncol=2) + geom_smooth(method = &quot;lm&quot;, formula = method, se = F) + stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), label.x.npc = &quot;right&quot;, label.y.npc = -1, formula = method, parse = TRUE, size = 6) p2 + theme_light(base_size = 20) . and everything seems to work fine. The function is quite brutal, we can indeed change also the distributions used, but it is very flexible and does its job. so now we can generate as much as we want y-s dataset .",
            "url": "https://jojosgithub.github.io/blog/r/ggplot/recipes/simpson/2021/07/04/ys.html",
            "relUrl": "/r/ggplot/recipes/simpson/2021/07/04/ys.html",
            "date": " • Jul 4, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I’m a researcher at the National Research Council of Italy at the “Giulio Natta” Institute of Chemical Sciences and Technologies (Scitec-Cnr).I started to be interested in multivariate statistics techniques applied to data from physic-chemical analysis methods 15 years ago during my Ph.D. and to apply it to material science ever since. Enthusiast about programming in R and Python in order to write tools for everyday laboratory activities. FOSS advocate. Messy coder. I’ve written also a book on this topic: “Statistical and Multivariate Analysis in Material Science” that you can find here https://amzn.com/B08W8W5WSF .",
          "url": "https://jojosgithub.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jojosgithub.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}